<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Ollama Chat UI</title>
    <style>
        /* --- General Styles --- */
        :root {
            --user-msg-bg: #0b63d4;
            --assistant-msg-bg: #f0f0f0;
            --code-bg: #2d2d2d;
            --code-text: #f8f8f2;
            --border-color: #ccc;
            --header-bg: #333;
            --button-bg: #007bff;
            --button-hover-bg: #0056b3;
            --body-bg: #eef2f5; /* Lighter background */
        }

        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            background-color: var(--body-bg);
            color: #333;
        }

        /* --- Header --- */
        #header {
            background-color: var(--header-bg);
            color: white;
            padding: 12px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            z-index: 10; /* Ensure header is above chatbox content */
        }

        #header label {
            margin-right: 10px;
            font-weight: 500;
        }

        #modelSelect {
            padding: 8px 12px;
            border: 1px solid #555;
            border-radius: 4px;
            background-color: #444444;
            color: white;
            min-width: 170px;
            cursor: pointer;
        }
         #modelSelect:focus {
             outline: 2px solid var(--button-bg);
             outline-offset: 1px;
         }

        #status {
            font-size: 0.9em;
            color: #bbb;
            margin-left: 20px;
        }

        /* --- Chatbox & Messages --- */
        #chatbox {
            flex-grow: 1;
            overflow-y: auto;
            padding: 25px;
            display: flex;
            flex-direction: column;
            gap: 15px; /* Spacing between messages */
        }

        .message {
            padding: 12px 18px;
            border-radius: 18px;
            max-width: 85%;
            line-height: 1.5;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            word-wrap: break-word; /* Prevent long words from overflowing */
        }

        .user-message {
            background-color: var(--user-msg-bg);
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 6px;
            margin-left: auto;
        }

        .assistant-message {
            background-color: var(--assistant-msg-bg);
            color: #333;
            align-self: flex-start;
            border-bottom-left-radius: 6px;
            margin-right: auto;
            /* white-space: pre-wrap; Removed here, handled by code blocks */
        }

         .assistant-message strong { /* Model name label */
             display: block;
             font-size: 0.85em;
             color: #555;
             margin-bottom: 6px;
             font-weight: 600;
         }

        .error-message {
             background-color: #f8d7da;
             color: #721c24;
             border: 1px solid #f5c6cb;
             align-self: center;
             max-width: 90%;
             border-radius: 8px;
        }

        /* --- Code Block Styling --- */
        .code-block-wrapper {
            position: relative;
            margin: 10px 0;
            border-radius: 8px; /* Rounded corners for the wrapper */
            overflow: hidden; /* Keep button contained */
        }

        pre {
            background-color: var(--code-bg);
            color: var(--code-text);
            padding: 15px;
            border-radius: 8px; /* Match wrapper */
            overflow-x: auto; /* Enable horizontal scroll for long lines */
            margin: 0; /* Remove default margin */
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
            white-space: pre; /* Preserve whitespace but allow wrapping */
        }

        code {
            font-family: inherit; /* Inherit font from pre */
            white-space: inherit; /* Inherit whitespace handling */
        }

        .copy-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background-color: #555;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
            opacity: 0.7;
            transition: opacity 0.2s, background-color 0.2s;
        }

        .code-block-wrapper:hover .copy-btn {
            opacity: 1;
        }

        .copy-btn:hover {
            background-color: #777;
        }

         .copy-btn.copied {
             background-color: #28a745; /* Green background when copied */
             opacity: 1;
         }

        /* --- Input Area --- */
        #input-area {
            display: flex;
            padding: 15px 25px;
            background-color: #f8f8f8;
            border-top: 1px solid var(--border-color);
            flex-shrink: 0;
            align-items: flex-end; /* Align items to bottom for multi-line */
            gap: 10px; /* Gap between textarea and button */
        }

        #userInput {
            flex-grow: 1;
            padding: 10px 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            resize: none;
            font-family: inherit;
            font-size: 1em;
            line-height: 1.4;
            max-height: 150px; /* Limit auto-growth height */
            overflow-y: auto;
            background-color: #fff;
        }
        #userInput:focus {
            outline: none;
            border-color: var(--button-bg);
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }


        #sendButton {
            padding: 10px 20px;
            background-color: var(--button-bg);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 1em;
            font-weight: 500;
            height: 42px; /* Match typical button height */
        }

        #sendButton:hover {
            background-color: var(--button-hover-bg);
        }
         #sendButton:disabled {
             background-color: #aaa;
             cursor: not-allowed;
         }
    </style>
</head>
<body>

    <div id="header">
        <div>
            <label for="modelSelect">Select Model:</label>
            <select id="modelSelect"></select>
        </div>
        <div id="status">Idle</div>
    </div>

    <div id="chatbox">
        <!-- Chat messages will appear here -->
    </div>

    <div id="input-area">
        <textarea id="userInput" placeholder="Type your message here..." rows="1"></textarea>
        <button id="sendButton">Send</button>
    </div>

    <script>
        const modelSelect = document.getElementById('modelSelect');
        const chatbox = document.getElementById('chatbox');
        const userInput = document.getElementById('userInput');
        const sendButton = document.getElementById('sendButton');
        const statusDiv = document.getElementById('status');

        const OLLAMA_API_BASE_URL = 'http://localhost:11434';

        let conversationHistory = [];
        let currentAssistantMessageDiv = null; // Reference to the assistant's outer message div
        let currentAssistantContentSpan = null; // Reference to the span holding streaming text
        let abortController = null; // To allow aborting requests if needed (optional, not fully implemented here)

        // --- Fetch available models ---
        async function fetchModels() {
            statusDiv.textContent = 'Fetching models...';
            sendButton.disabled = true;
            try {
                const response = await fetch(`${OLLAMA_API_BASE_URL}/api/tags`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();

                modelSelect.innerHTML = ''; // Clear existing options
                if (data.models && data.models.length > 0) {
                    data.models.sort((a, b) => a.name.localeCompare(b.name)).forEach(model => { // Sort models alphabetically
                        const option = document.createElement('option');
                        option.value = model.name;
                        option.textContent = model.name;
                        modelSelect.appendChild(option);
                    });
                    statusDiv.textContent = 'Idle';
                    sendButton.disabled = false;
                } else {
                    addMessageToChatbox('Error', 'No Ollama models found. Run `ollama serve` & pull a model (e.g., `ollama pull llama3`).');
                    statusDiv.textContent = 'No models';
                }
            } catch (error) {
                console.error('Error fetching models:', error);
                addMessageToChatbox('Error', `Failed to fetch models. Is Ollama running at ${OLLAMA_API_BASE_URL}? Error: ${error.message}`);
                statusDiv.textContent = 'Fetch Error';
            }
        }

        // --- Add a message container to the chatbox ---
        function addMessageContainer(sender, modelName = '') {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message');

            if (sender === 'user') {
                messageElement.classList.add('user-message');
            } else if (sender === 'assistant') {
                messageElement.classList.add('assistant-message');
                // Add model label
                const modelLabel = document.createElement('strong');
                modelLabel.textContent = `${modelName}:`;
                messageElement.appendChild(modelLabel);
                // Add span for content (initially empty or for streaming text)
                const contentSpan = document.createElement('span');
                messageElement.appendChild(contentSpan);
                currentAssistantContentSpan = contentSpan; // Store reference for streaming
            } else if (sender === 'Error') {
                 messageElement.classList.add('error-message');
            }

            chatbox.appendChild(messageElement);
            chatbox.scrollTop = chatbox.scrollHeight;
             return messageElement;
        }

        // --- Render message content (handling code blocks) ---
        function renderMessageContent(container, textContent, sender) {
             if (sender === 'user' || sender === 'Error') {
                 // For user and error messages, just set text content directly
                 container.appendChild(document.createTextNode(textContent));
             } else if (sender === 'assistant') {
                 // For assistant, parse for code blocks
                 const codeBlockRegex = /```(?:([\w-]+)\n)?([\s\S]*?)```/g; // Capture language (optional) and content
                 let lastIndex = 0;
                 let match;

                 // Clear the streaming span if it exists
                 const streamingSpan = container.querySelector('span');
                 if (streamingSpan) streamingSpan.remove();
                 currentAssistantContentSpan = null; // Clear reference


                 while ((match = codeBlockRegex.exec(textContent)) !== null) {
                     // 1. Add text before the code block
                     if (match.index > lastIndex) {
                         container.appendChild(document.createTextNode(textContent.substring(lastIndex, match.index)));
                     }

                     // 2. Add the code block
                     const language = match[1] || 'plaintext'; // Language identifier (optional)
                     const code = match[2].trim(); // The actual code content

                     const wrapper = document.createElement('div');
                     wrapper.classList.add('code-block-wrapper');

                     const pre = document.createElement('pre');
                     const codeElement = document.createElement('code');
                     // Optional: Add language class for syntax highlighting libraries
                     // codeElement.classList.add(`language-${language}`);
                     codeElement.textContent = code;
                     pre.appendChild(codeElement);

                     const copyButton = document.createElement('button');
                     copyButton.textContent = 'Copy';
                     copyButton.classList.add('copy-btn');
                     copyButton.addEventListener('click', () => copyCodeToClipboard(code, copyButton));

                     wrapper.appendChild(pre);
                     wrapper.appendChild(copyButton);
                     container.appendChild(wrapper);

                     lastIndex = codeBlockRegex.lastIndex;
                 }

                 // 3. Add any remaining text after the last code block
                 if (lastIndex < textContent.length) {
                     container.appendChild(document.createTextNode(textContent.substring(lastIndex)));
                 }
             }
             chatbox.scrollTop = chatbox.scrollHeight; // Ensure scroll after rendering
        }

        // --- Copy code to clipboard ---
        async function copyCodeToClipboard(code, button) {
            try {
                await navigator.clipboard.writeText(code);
                button.textContent = 'Copied!';
                button.classList.add('copied');
                setTimeout(() => {
                    button.textContent = 'Copy';
                    button.classList.remove('copied');
                }, 1500); // Reset button text after 1.5 seconds
            } catch (err) {
                console.error('Failed to copy code: ', err);
                button.textContent = 'Error';
                 setTimeout(() => {
                     button.textContent = 'Copy';
                 }, 1500);
            }
        }


        // --- Send message to Ollama ---
        async function sendMessage() {
            const messageText = userInput.value.trim();
            const selectedModel = modelSelect.value;

            if (!messageText) return;
            if (!selectedModel) {
                 const errContainer = addMessageContainer('Error');
                 renderMessageContent(errContainer, 'Please select a model first.', 'Error');
                 return;
            }

            // Add user message to UI and history
            const userContainer = addMessageContainer('user');
            renderMessageContent(userContainer, messageText, 'user');
            conversationHistory.push({ role: "user", content: messageText });

            userInput.value = '';
            userInput.style.height = 'auto'; // Reset height before calculating new one
            userInput.style.height = '42px'; // Set back to default single line approx height
            userInput.focus();
            sendButton.disabled = true;
            statusDiv.textContent = `Asking ${selectedModel}...`;

            // Prepare and add assistant message structure to UI
            currentAssistantMessageDiv = addMessageContainer('assistant', selectedModel);
            let accumulatedAssistantResponse = ""; // To store full response for history and final render

            // Initialize assistant message in history - will be updated later
            conversationHistory.push({ role: "assistant", content: "" }); // Placeholder

            abortController = new AbortController(); // Allow aborting fetch

            try {
                const response = await fetch(`${OLLAMA_API_BASE_URL}/api/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: selectedModel,
                        messages: conversationHistory.slice(0, -1), // Send history *before* the placeholder
                        stream: true
                    }),
                    signal: abortController.signal // Link fetch to abort controller
                });

                 if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! Status: ${response.status} - ${errorText}`);
                }

                // --- Handle Streaming Response ---
                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                 while (true) {
                    const { done, value } = await reader.read();
                    if (done) break; // Exit loop when stream is finished

                    const chunk = decoder.decode(value, { stream: true });
                    const jsonResponses = chunk.split('\n').filter(line => line.trim() !== '');

                    jsonResponses.forEach(jsonResponse => {
                        try {
                             const parsedResponse = JSON.parse(jsonResponse);
                             if (parsedResponse.message && parsedResponse.message.content) {
                                 const contentPiece = parsedResponse.message.content;
                                 accumulatedAssistantResponse += contentPiece;
                                 // Update the streaming span's text content
                                 if (currentAssistantContentSpan) {
                                     currentAssistantContentSpan.textContent += contentPiece;
                                     chatbox.scrollTop = chatbox.scrollHeight; // Keep scrolled down
                                 }
                            }
                             if (parsedResponse.done && parsedResponse.message?.content === '') {
                                // Official 'done' marker from Ollama for this request often has empty content
                                // console.log("Stream processing for this request marked done by Ollama.");
                             }
                        } catch (e) {
                            console.warn("Failed to parse JSON chunk:", jsonResponse, e);
                        }
                    });
                 } // End while loop (stream finished)

                // --- Final Processing after Stream ---
                // Update history with the final accumulated content
                 if (conversationHistory.length > 0 && conversationHistory[conversationHistory.length - 1].role === "assistant") {
                    conversationHistory[conversationHistory.length - 1].content = accumulatedAssistantResponse;
                 }

                // Render the complete message with code block handling
                 if (currentAssistantMessageDiv) {
                    renderMessageContent(currentAssistantMessageDiv, accumulatedAssistantResponse, 'assistant');
                 }

            } catch (error) {
                console.error('Error sending message:', error);
                 // Handle fetch cancellation
                 if (error.name === 'AbortError') {
                     console.log('Fetch aborted.');
                     statusDiv.textContent = 'Request Cancelled';
                      // Optionally remove the partial assistant message container
                     if(currentAssistantMessageDiv) currentAssistantMessageDiv.remove();
                      // Remove placeholder from history
                      if (conversationHistory.length > 0 && conversationHistory[conversationHistory.length - 1].role === "assistant") {
                          conversationHistory.pop();
                      }
                     return; // Stop further processing
                 }

                // Display error in the UI
                 const errorText = `Error: ${error.message}. Check Ollama connection & model availability.`;
                 if (currentAssistantMessageDiv) {
                     // If we started an assistant message, replace its content with error
                     currentAssistantMessageDiv.innerHTML = ''; // Clear existing content (label, span)
                     currentAssistantMessageDiv.classList.remove('assistant-message');
                     currentAssistantMessageDiv.classList.add('error-message');
                     renderMessageContent(currentAssistantMessageDiv, errorText, 'Error');
                 } else {
                     // Otherwise, add a new error message block
                     const errContainer = addMessageContainer('Error');
                     renderMessageContent(errContainer, errorText, 'Error');
                 }
                  // Remove potentially incomplete/placeholder assistant message from history
                 if (conversationHistory.length > 0 && conversationHistory[conversationHistory.length - 1].role === "assistant") {
                     conversationHistory.pop();
                 }

            } finally {
                statusDiv.textContent = 'Idle';
                sendButton.disabled = false;
                currentAssistantMessageDiv = null; // Reset references
                currentAssistantContentSpan = null;
                abortController = null; // Reset controller
                userInput.focus();
            }
        }

        // --- Event Listeners ---
        sendButton.addEventListener('click', sendMessage);

        userInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        });

         // Auto-resize textarea
         userInput.addEventListener('input', () => {
            userInput.style.height = 'auto'; // Temporarily shrink
             const scrollHeight = userInput.scrollHeight;
             const maxHeight = 150; // Max height defined in CSS
             userInput.style.height = Math.min(scrollHeight, maxHeight) + 'px';
         });

        // --- Initial Setup ---
        window.onload = () => {
             fetchModels();
             userInput.focus();
        }; 

    </script>

</body>
</html>